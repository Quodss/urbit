load("@rules_cc//cc:defs.bzl", "cc_library")
# load("@rules_foreign_cc//foreign_cc:defs.bzl", "configure_make")

# filegroup(
#     name = "srcs",
#     srcs = glob(["**"]),
# )

# configure_make(
#     name = "sigsegv",
#     autoconf = True,
#     autoreconf = True,
#     configure_in_place = True,
#     lib_source = ":srcs",
#     out_static_libs = select({
#         "@//:windows-x86_64": ["libsigsegv.lib"],
#         "//conditions:default": ["libsigsegv.a"],
#     }),
#     visibility = ["//visibility:public"],
# )

# filegroup(
#     name = "hdrs",
#     srcs = [
#         "@//third_party/sigsegv/linux-amd64:config.h",
#         "@//third_party/sigsegv/linux-amd64:sigsegv.h",
#     ],
# )

# cc_library(
#   name = "linux-amd64",
#   hdrs = glob(["*.h"]),
#   include_prefix = ".",
#   visibility = ["//visibility:public"]
# )

genrule(
    name = "hdrs-linux-amd64",
    srcs = ["@//third_party/sigsegv/linux-amd64"],
    outs = ["src/config.h", "src/sigsegv.h"],
    cmd = """
for f in $(locations @//third_party/sigsegv/linux-amd64); do
  cp $$f $(RULEDIR)/src/$$(basename $$f)
done
"""
)

cc_library(
    name = "sigsegv",
    srcs = glob(["src/**/*.h"]) + [
        "src/handler.c",
        "src/stackvma.c",
        "src/leave.c",
        "src/dispatcher.c",
        "src/version.c",
    ],
    textual_hdrs = [
        # linux-amd64
        "src/leave-nop.c",
        "src/handler-unix.c",
        "src/stackvma-linux.c",
        "src/stackvma-simple.c",
        "src/stackvma-rofile.c",
        "src/stackvma-mincore.c",
        "src/stackvma-vma-iter.c",
    ],
    hdrs = [":hdrs-linux-amd64"],
    includes = ["src"],
   visibility = ["//visibility:public"]
)
